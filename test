using System;
using System.Security.Cryptography;
using System.Text;

public class AesGcmDecryptionService
{
    public static string Decrypt(string keyStr, string input, string saltStr, int iterations, string format)
    {
        // Validate inputs
        if (string.IsNullOrEmpty(keyStr) || string.IsNullOrEmpty(input) || string.IsNullOrEmpty(saltStr))
        {
            throw new ArgumentException("Key, input, and salt cannot be empty.");
        }

        if (saltStr.Length != 12)
        {
            throw new ArgumentException("Salt must be exactly 12 characters long.");
        }

        if (iterations < 1000)
        {
            throw new ArgumentException("Iterations must be at least 1000.");
        }

        // Convert key and salt to bytes and derive the AES key
        byte[] salt = Encoding.UTF8.GetBytes(saltStr);
        byte[] keyBytes = DeriveKey(keyStr, salt, iterations);

        // Convert the input to a byte array based on the selected format (hex or base64)
        byte[] encryptedArray = format.ToLower() == "hex" ? ConvertHexToBytes(input) : Convert.FromBase64String(input);

        // Ensure data length is sufficient (12 bytes IV + encrypted data)
        if (encryptedArray.Length < 28)
        {
            throw new ArgumentException("Invalid input data length.");
        }

        // Extract IV (first 12 bytes), encrypted data, and authentication tag
        byte[] iv = new byte[12];
        Array.Copy(encryptedArray, 0, iv, 0, iv.Length);

        byte[] encryptedData = new byte[encryptedArray.Length - iv.Length];
        Array.Copy(encryptedArray, iv.Length, encryptedData, 0, encryptedData.Length);

        // Perform AES-GCM decryption
        try
        {
            return DecryptAesGcm(encryptedData, keyBytes, iv);
        }
        catch (CryptographicException)
        {
            throw new Exception("Error: Invalid decryption key or tampered data.");
        }
    }

    private static byte[] DeriveKey(string password, byte[] salt, int iterations)
    {
        using (var pbkdf2 = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256))
        {
            return pbkdf2.GetBytes(32); // AES-256 key
        }
    }

   private static string DecryptAesGcm(byte[] encryptedDataWithTag, byte[] key, byte[] iv)
{
    // Separate the encrypted data and the tag (last 16 bytes are usually the tag)
    int tagLength = 16;
    int encryptedDataLength = encryptedDataWithTag.Length - tagLength;

    // Extract encrypted data and tag
    byte[] encryptedData = new byte[encryptedDataLength];
    byte[] tag = new byte[tagLength];

    Array.Copy(encryptedDataWithTag, 0, encryptedData, 0, encryptedDataLength);
    Array.Copy(encryptedDataWithTag, encryptedDataLength, tag, 0, tagLength);

    // Perform decryption
    byte[] decryptedData = new byte[encryptedData.Length];
    using (var aesGcm = new AesGcm(key))
    {
        aesGcm.Decrypt(iv, encryptedData, tag, decryptedData);
    }

    return Encoding.UTF8.GetString(decryptedData);
}


    private static byte[] ConvertHexToBytes(string hex)
    {
        byte[] bytes = new byte[hex.Length / 2];
        for (int i = 0; i < hex.Length; i += 2)
        {
            bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);
        }
        return bytes;
    }
}
